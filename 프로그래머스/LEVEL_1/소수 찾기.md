## 문제설명
>
1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.
소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.
(1은 소수가 아닙니다.)

## 제한 조건
> n은 2이상 1000000이하의 자연수입니다.

## 입출력 예
>
|n|result|
|-|------|
|10|4|
|5|3|


- 입출력 예 #1
    - 1부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환
- 입출력 예 #2
    - 1부터 5 사이의 소수는 [2,3,5] 3개가 존재하므로 3를 반환

## 코드
```java
class Solution {
    public static boolean isPrime(int num){
        for(int i=2; i*i<=num; i++){
            if(num % i == 0) return false;
        }
        return true;
    }
    
    public int solution(int n) {
        int answer = 0;
        int[] arr = new int[n+1];
        for(int i=2; i<n+1; i++) {
            if(this.isPrime(i)) {
                answer++;
            }
                
        }
        
        return answer;
    }
}
```

채점을 시작합니다.
정확성  테스트
테스트 1 〉	통과 (0.02ms, 71.4MB)
테스트 2 〉	통과 (0.04ms, 76.1MB)
테스트 3 〉	통과 (0.08ms, 72.1MB)
테스트 4 〉	통과 (0.16ms, 70.5MB)
테스트 5 〉	통과 (0.13ms, 74.6MB)
테스트 6 〉	통과 (1.02ms, 75.7MB)
테스트 7 〉	통과 (0.33ms, 75.3MB)
테스트 8 〉	통과 (0.65ms, 71.9MB)
테스트 9 〉	통과 (1.10ms, 66.2MB)
테스트 10 〉	통과 (40.16ms, 95.9MB)
테스트 11 〉	통과 (176.18ms, 94.6MB)
테스트 12 〉	통과 (47.17ms, 83.2MB)
효율성  테스트
테스트 1 〉	통과 (202.84ms, 56.2MB)
테스트 2 〉	통과 (177.94ms, 55.8MB)
테스트 3 〉	통과 (201.01ms, 56.1MB)
테스트 4 〉	통과 (197.83ms, 55.1MB)
채점 결과
정확성: 75.0
효율성: 25.0
합계: 100.0 / 100.0

## 풀이
- 먼저 소수란 1과 자기 자신으로만 나누어지는 수를 의미한다.
**- 즉 자기 자신보다 작은 수들을 나누어봐서 하나라도 나누어지면 소수가 아닌 것!.**
- 소수 구하는 공식을 이용하여 구현
